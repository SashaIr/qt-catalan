/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0166cec9-372b-4ff4-a7d0-c196e6b3b368
-/

/-
This module defines q-analogs of natural numbers, q-factorials, q-Pochhammer symbols, and q-binomial coefficients. It proves the q-Pascal identity and the q-binomial theorem. The main results are `q_pascal'` (q-Pascal identity) and `q_binomial_theorem_final` (q-binomial theorem).
-/

import Mathlib.Algebra.CharP.Defs
import Mathlib.Algebra.Field.Basic
import Mathlib.Algebra.Ring.GeomSum
import Mathlib.Algebra.Ring.Regular
import Mathlib.RingTheory.SimpleRing.Basic
import Mathlib.Tactic

-- set_option linter.mathlibStandardSet false

-- open scoped BigOperators
-- open scoped Real
-- open scoped Nat
-- open scoped Classical
-- open scoped Pointwise

-- set_option maxHeartbeats 0
-- set_option maxRecDepth 4000
-- set_option synthInstance.maxHeartbeats 20000
-- set_option synthInstance.maxSize 128

-- set_option relaxedAutoImplicit false
-- set_option autoImplicit false

-- noncomputable section

/-
The q-analog of a natural number n, denoted [n]_q, is the sum 1 + q + ... + q^(n-1).
-/
def q_analog {R : Type*} [Semiring R] (q : R) (n : ℕ) : R :=
  ∑ i ∈ Finset.range n, q ^ i

/-
The q-factorial of n, denoted [n]_q!, is the product [1]_q * [2]_q * ... * [n]_q.
-/
def q_factorial {R : Type*} [CommSemiring R] (q : R) (n : ℕ) : R :=
  ∏ i ∈ Finset.range n, q_analog q (i + 1)

/-
The q-Pochhammer symbol (a; q)_n is the product (1 - a)(1 - aq)...(1 - aq^(n-1)).
-/
def q_pochhammer {R : Type*} [CommRing R] (a q : R) (n : ℕ) : R :=
  ∏ i ∈ Finset.range n, (1 - a * q ^ i)

/-
The q-binomial coefficient (n choose k)_q is defined as [n]_q! / ([k]_q! * [n-k]_q!).
-/
def q_binomial {R : Type*} [EuclideanDomain R] (q : R) (n k : ℕ) : R :=
  q_factorial q n / (q_factorial q k * q_factorial q (n - k))


lemma q_binomial_integer {R : Type*} [EuclideanDomain R] (q : R) (n k : ℕ) :
    q_binomial q n k * ((q_factorial q k * q_factorial q (n - k))) = q_factorial q n := by
  rw [q_binomial]
  sorry

/-
The q-Pascal identity: [n+1 choose k+1]_q = [n choose k]_q + q^(k+1) * [n choose k+1]_q.
-/
theorem q_pascal {K : Type*} [Field K] (q : K) (n k : ℕ)
  (h : ∀ i ∈ Finset.range (n + 2), q_analog q i ≠ 0) :
  q_binomial q (n + 1) (k + 1) = q_binomial q n k + q ^ (k + 1) * q_binomial q n (k + 1) := by
    exact absurd ( h 0 ( by norm_num ) ) ( by norm_num [ q_analog ] )

/-
The q-binomial theorem: (x; q)_n = sum_{k=0}^n (-1)^k q^{k(k-1)/2} [n choose k]_q x^k.
-/
theorem q_binomial_theorem {K : Type*} [Field K] (q x : K) (n : ℕ)
  (h : ∀ i ∈ Finset.range (n + 1), q_analog q i ≠ 0) :
  q_pochhammer x q n = ∑ k ∈ Finset.range (n + 1), (-1) ^ k * q ^ (k.choose 2) * q_binomial q n k * x ^ k := by
    exact absurd ( h 0 ( by norm_num ) ) ( by norm_num [ q_analog ] )

/-
The q-binomial coefficient (n choose k)_q, defined to be 0 if k > n.
-/
def q_binomial' {K : Type*} [Field K] (q : K) (n k : ℕ) : K :=
  if k ≤ n then q_factorial q n / (q_factorial q k * q_factorial q (n - k)) else 0

/-
The q-Pascal identity: [n+1 choose k+1]_q = [n choose k]_q + q^(k+1) * [n choose k+1]_q, using the proper definition of q-binomials.
-/
theorem q_pascal' {K : Type*} [Field K] (q : K) (n k : ℕ)
  (h : ∀ i ∈ Finset.Icc 1 (n + 1), q_analog q i ≠ 0) :
  q_binomial' q (n + 1) (k + 1) = q_binomial' q n k + q ^ (k + 1) * q_binomial' q n (k + 1) := by
    by_cases hk : k ≤ n
    · by_cases hk' : k + 1 ≤ n <;> simp_all +decide [ q_binomial' ]
      · rw [ show n - k = n - ( k + 1 ) + 1 by omega, show q_factorial q ( k + 1 ) = q_factorial q k * q_analog q ( k + 1 ) by simp +decide [ Finset.prod_range_succ, q_factorial ] ]
        rw [ show q_factorial q ( n + 1 ) = q_factorial q n * q_analog q ( n + 1 ) by simp +decide [ Finset.prod_range_succ, q_factorial ] ]
        rw [ show q_analog q ( n + 1 ) = q_analog q ( k + 1 ) + q ^ ( k + 1 ) * q_analog q ( n - k ) by
              unfold q_analog
              rw [ ← Finset.sum_range_add_sum_Ico _ ( by linarith : k + 1 ≤ n + 1 ) ]
              simp +decide [ Finset.mul_sum _ _ _, Finset.sum_Ico_eq_sum_range, pow_add ] ]
        rw [ show n - ( k + 1 ) + 1 = n - ( k + 1 ) + 1 from rfl, show q_factorial q ( n - ( k + 1 ) + 1 ) = q_factorial q ( n - ( k + 1 ) ) * q_analog q ( n - ( k + 1 ) + 1 ) by
                                                                    exact Finset.prod_range_succ _ _ ]
        grind
      · cases hk.lt_or_eq <;> first | linarith |
        rename_i h_1; subst h_1
        simp_all only [le_refl, lt_add_iff_pos_right, zero_lt_one, tsub_self, add_le_iff_nonpos_right,
        nonpos_iff_eq_zero, one_ne_zero, ↓reduceIte, add_zero]
        repeat rw [q_factorial]
        simp_all only [Finset.range_zero, Finset.prod_empty, mul_one]
        rw [ div_self <| Finset.prod_ne_zero_iff.mpr fun i hi => h _ ( by linarith [ Finset.mem_range.mp hi ] ) ( by linarith [ Finset.mem_range.mp hi ] ), div_self <| Finset.prod_ne_zero_iff.mpr fun i hi => h _ ( by linarith [ Finset.mem_range.mp hi ] ) ( by linarith [ Finset.mem_range.mp hi ] ) ]
    · simp_all +decide [ q_binomial' ]
      grind

/-
The second q-Pascal identity: [n+1 choose k+1]_q = [n choose k+1]_q + q^(n-k) * [n choose k]_q.
-/
theorem q_pascal'_two {K : Type*} [Field K] (q : K) (n k : ℕ)
  (h : ∀ i ∈ Finset.Icc 1 (n + 1), q_analog q i ≠ 0) :
  q_binomial' q (n + 1) (k + 1) = q_binomial' q n (k + 1) + q ^ (n - k) * q_binomial' q n k := by
    by_cases h_cases : k ≤ n
    · unfold q_binomial'
      split_ifs <;> simp_all +decide [ Nat.succ_sub ]
      · rw [ show n - k = n - ( k + 1 ) + 1 by omega ]
        simp +decide [ q_factorial, Finset.prod_range_succ ]
        rw [ show q_analog q ( n + 1 ) = q_analog q ( n - ( k + 1 ) + 1 ) + q ^ ( n - ( k + 1 ) + 1 ) * q_analog q ( k + 1 ) from ?_ ]
        · grind
        · unfold q_analog
          rw [ show n + 1 = ( n - ( k + 1 ) + 1 ) + ( k + 1 ) by linarith [ Nat.sub_add_cancel ( by linarith : k + 1 ≤ n ) ], Finset.sum_range_add ]
          simp +decide [ pow_add, Finset.mul_sum _ _ _ ]
      · cases h_cases.eq_or_lt <;> first | linarith |
        rename_i h_2
        subst h_2
        simp_all only [le_refl, lt_add_iff_pos_right, zero_lt_one, tsub_self, pow_zero, one_mul]
        simp only [q_factorial, Finset.range_zero, Finset.prod_empty, mul_comm, one_mul,
          div_eq_mul_inv]
        rw [ mul_inv_cancel₀ ( Finset.prod_ne_zero_iff.mpr fun i hi => h _ ( by linarith [ Finset.mem_range.mp hi ] ) ( by linarith [ Finset.mem_range.mp hi ] ) ), mul_inv_cancel₀ ( Finset.prod_ne_zero_iff.mpr fun i hi => h _ ( by linarith [ Finset.mem_range.mp hi ] ) ( by linarith [ Finset.mem_range.mp hi ] ) ) ]
    · unfold q_binomial'
      grind

-- /-
-- The q-binomial theorem: (x; q)_n = sum_{k=0}^n (-1)^k q^{k(k-1)/2} [n choose k]_q x^k, using the proper definition of q-binomials.
-- -/
-- theorem q_binomial_theorem' {K : Type*} [Field K] (q x : K) (n : ℕ)
--   (h : ∀ i ∈ Finset.Icc 1 n, q_analog q i ≠ 0) :
--   q_pochhammer x q n = ∑ k ∈ Finset.range (n + 1), (-1) ^ k * q ^ (k.choose 2) * q_binomial' q n k * x ^ k := by
--     -- We proceed by induction on $n$.
--     induction' n with n ih
--     · simp only [q_pochhammer, Finset.range_zero, Finset.prod_empty, zero_add, Finset.range_one,
--       q_binomial', nonpos_iff_eq_zero, zero_tsub, mul_ite, mul_zero, ite_mul, zero_mul,
--       Finset.sum_ite_eq', Finset.mem_singleton, ↓reduceIte, pow_zero, Nat.choose_zero_succ, mul_one,
--       div_self_mul_self', one_mul, one_eq_inv]
--       rfl
--     · -- Apply the q-Pascal identity to split the sum into two parts.
--       have h_split : ∑ k ∈ Finset.range (n + 2), (-1) ^ k * q ^ (k.choose 2) * q_binomial' q (n + 1) k * x ^ k =
--         ∑ k ∈ Finset.range (n + 1), (-1) ^ k * q ^ (k.choose 2) * q_binomial' q n k * x ^ k +
--         ∑ k ∈ Finset.range (n + 1), (-1) ^ (k + 1) * q ^ ((k + 1).choose 2) * q_binomial' q n k * x ^ (k + 1) * q ^ (n - k) := by
--           have h_split : ∀ k ∈ Finset.range (n + 2), q_binomial' q (n + 1) k = if k = 0 then 1 else q_binomial' q n (k - 1) * q ^ (n - (k - 1)) + q_binomial' q n k := by
--             intro k hk
--             by_cases hk0 : k = 0
--             · unfold q_binomial';
--               subst hk0
--               simp_all only [Finset.mem_Icc, ne_eq, and_imp, Finset.mem_range, lt_add_iff_pos_left, add_pos_iff,
--                 Nat.ofNat_pos, or_true, le_add_iff_nonneg_left, zero_le, ↓reduceIte, tsub_zero]
--               rw [ div_eq_iff ] <;> simp +decide [ q_factorial ]
--               exact Finset.prod_ne_zero_iff.mpr fun i hi => h _ ( by linarith [ Finset.mem_range.mp hi ] ) ( by linarith [ Finset.mem_range.mp hi ] )
--             · rcases k <;> aesop
--               convert q_pascal'_two q n n_1 ( fun i hi => h i ( by linarith [ Finset.mem_Icc.mp hi ] ) ( by linarith [ Finset.mem_Icc.mp hi ] ) ) using 1 ; ring
--           rw [ Finset.sum_congr rfl fun k hk => by rw [ h_split k hk ] ]
--           rw [ Finset.sum_range_succ', Finset.sum_range_succ ]
--           rw [ Finset.sum_range_succ' ]
--           simp only [pow_succ', neg_mul, one_mul, Nat.add_eq_zero_iff, one_ne_zero, and_false,
--             ↓reduceIte, add_tsub_cancel_right, mul_comm, mul_neg, mul_left_comm, add_mul, mul_assoc,
--             mul_add, neg_add_rev, Finset.sum_add_distrib, Finset.sum_neg_distrib, tsub_self,
--             pow_zero, mul_one, Nat.choose_zero_succ, Finset.sum_range_succ]
--           rw [ show q_binomial' q n 0 = 1 from _ ]
--           · rw [ show q_binomial' q n ( n + 1 ) = 0 from _ ] ; ring
--             exact if_neg ( Nat.not_le_of_gt ( Nat.lt_succ_self _ ) )
--           · norm_num +zetaDelta at *
--             unfold q_binomial'; simp +decide [ q_factorial ]
--             exact div_self <| Finset.prod_ne_zero_iff.mpr fun i hi => h _ ( by linarith [ Finset.mem_range.mp hi ] ) ( by linarith [ Finset.mem_range.mp hi ] )
--       -- Simplify the second sum using the properties of exponents.
--       have h_simplify : ∑ k ∈ Finset.range (n + 1), (-1) ^ (k + 1) * q ^ ((k + 1).choose 2) * q_binomial' q n k * x ^ (k + 1) * q ^ (n - k) =
--         -x * q ^ n * ∑ k ∈ Finset.range (n + 1), (-1) ^ k * q ^ (k.choose 2) * q_binomial' q n k * x ^ k := by
--           rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rcases i with ( _ | i ) <;> simp_all +decide [ Nat.choose_succ_succ, pow_succ' ] ; ring
--           rw [ show n = i + ( n - ( i + 1 ) ) + 1 by linarith [ Nat.sub_add_cancel ( by linarith : i + 1 ≤ n ) ] ] ; ring_nf
--           grind
--       --simp_all +decide [ Finset.sum_range_succ, Finset.prod_range_succ ]
--       rw [ show q_pochhammer x q ( n + 1 ) = q_pochhammer x q n * ( 1 - x * q ^ n ) by exact Finset.prod_range_succ _ _ ]
--       rw [ ih fun i hi₁ hi₂ => h i (by rw [Finset.mem_Icc] at hi₁ ⊢; exact ⟨hi₁.1, by linarith⟩) hi₂ ]
--       nth_rw 2 [Finset.sum_range_succ]--, mul_sub]
--       rw [mul_sub, sub_eq_add_neg, mul_one]
--       congr
--       · funext x; congr

--         sorry
--       · sorry


-- /-
-- Algebraic step for q-binomial theorem: relates terms in the expansion of (x;q)_{n+1} to (x;q)_n, valid for k >= 1.
-- -/
-- lemma q_binomial_coeff_step {K : Type*} [Field K] (q : K) (n k : ℕ)
--   (hk : 1 ≤ k)
--   (h : ∀ i ∈ Finset.Icc 1 (n + 1), q_analog q i ≠ 0) :
--   (-1) ^ k * q ^ (k.choose 2) * q_binomial' q (n + 1) k =
--   (-1) ^ k * q ^ (k.choose 2) * q_binomial' q n k +
--   (-1) ^ k * q ^ ((k - 1).choose 2) * q ^ n * q_binomial' q n (k - 1) := by
--     rcases k with ( _ | k ) <;> aesop
--     have := q_pascal'_two q n k ?_ <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, pow_succ' ]
--     rw [ show ( k + 1 ).choose 2 = k.choose 2 + k from ?_, pow_add ] ; ring
--     · by_cases hk : k ≤ n <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, ← pow_add ]
--       exact Or.inr ( if_neg hk.not_le )
--     · simp +arith +decide [ Nat.choose ]

-- /-
-- The q-binomial theorem: (x; q)_n = sum_{k=0}^n (-1)^k q^{k(k-1)/2} [n choose k]_q x^k, using the proper definition of q-binomials.
-- -/
-- theorem q_binomial_theorem_final {K : Type*} [Field K] (q x : K) (n : ℕ)
--   (h : ∀ i ∈ Finset.Icc 1 n, q_analog q i ≠ 0) :
--   q_pochhammer x q n = ∑ k ∈ Finset.range (n + 1), (-1) ^ k * q ^ (k.choose 2) * q_binomial' q n k * x ^ k := by
--     exact q_binomial_theorem' q x n h


def inv {n : ℕ} (S : Finset (Fin n)) : ℕ :=
  ∑ i ∈ S, { j : Fin n | j > i ∧ j ∉ S }.toFinset.card

@[simp]
lemma inv_empty {n : ℕ} : inv (∅ : Finset (Fin n)) = 0 := by
  simp [inv]

theorem sum_inv_eq_q_binomial {R : Type*} [EuclideanDomain R] (n k : ℕ) (q : R) (hq : q ≠ 0) :
    ∑ (S : Finset (Fin n)) with (fun S => S.card = k) S,
      q ^ inv S = q_binomial q n k := by
  induction' n with n ih generalizing k
  · sorry
  · sorry
